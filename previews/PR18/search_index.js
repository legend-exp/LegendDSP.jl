var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:module]","category":"page"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type, :constant]","category":"page"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [LegendDSP]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"api/#LegendDSP.LegendDSP","page":"API","title":"LegendDSP.LegendDSP","text":"LegendDSP\n\nTemplate for Julia packages.\n\n\n\n\n\n","category":"module"},{"location":"api/#LegendDSP.DSPConfig","page":"API","title":"LegendDSP.DSPConfig","text":"DSPConfig{T <: Real}\n\nConfiguration parameters for DSP algorithms.\n\nFields\n\nenc_pickoff::Quantity{<:T}: pick-off time for ENC noise calculations\nbl_mean::NTuple{2, Quantity{<:T}}: fit window for basline extraction\npz_fit::NTuple{2, Quantity{<:T}}: fit window for decay time extraction\nt0_threshold::T: ADC threshold for t0 determination\ne_grid_rt_trap::StepRangeLen{Quantity{<:T}}: rise time grid scan range for trapezoidal filter\ne_grid_ft_trap::StepRangeLen{Quantity{<:T}}: flat-top time grid scan range for trapezoidal filter\ne_grid_rt_zac::StepRangeLen{Quantity{<:T}}: rise time grid scan range for ZAC filter\ne_grid_ft_zac::StepRangeLen{Quantity{<:T}}: flat-top time grid scan range for ZAC filter\ne_grid_rt_cusp::StepRangeLen{Quantity{<:T}}: rise time grid scan range for CUSP filter\ne_grid_ft_cusp::StepRangeLen{Quantity{<:T}}: flat-top time grid scan range for CUSP filter\ne_grid_rt_sg::StepRangeLen{Quantity{<:T}}: window length grid scan range for SG filter\n\nExamples\n\nusing LegendDSP\nusing Unitful\n\ndsp_config = DSPConfig{Float64}(32.0u\"µs\", \n(0.0u\"µs\", 39.0u\"µs\"), \n(80.0u\"µs\", 110.0u\"µs\"), \n5.0, \n7.0u\"µs\":0.5u\"µs\":12.0u\"µs\", 1.0u\"µs\":0.2u\"µs\":4.0u\"µs\",\n7.0u\"µs\":0.5u\"µs\":12.0u\"µs\", 1.0u\"µs\":0.2u\"µs\":4.0u\"µs\", \n7.0u\"µs\":0.5u\"µs\":12.0u\"µs\", 1.0u\"µs\":0.2u\"µs\":4.0u\"µs\")\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDSP.IntersectMaximum","page":"API","title":"LegendDSP.IntersectMaximum","text":"struct IntersectMaximum <: Function\n\nFinds the intersects of a Y with a threshold and picking the maximum in a given time window. Constructors:\n\nIntersectMaximum(; fields...)\n\nFields:\n\nmintot::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: minimum time-over-threshold\nmaxtot::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: maximum time-over-threshold for max to appear\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDSP.create_dsp_config","page":"API","title":"LegendDSP.create_dsp_config","text":"create_dsp_config(dsp_metadata::PropDicts.PropDict)\n\nCreate a DSPConfig from a PropDict of DSP metadata.\n\nArguments\n\ndsp_metadata::PropDicts.PropDict: DSP metadata\n\nReturns\n\ndsp_config::DSPConfig: DSP configuration\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDSP.dsp_cusp_ft_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, Unitful.Quantity{T}}} where T<:Real","page":"API","title":"LegendDSP.dsp_cusp_ft_optimization","text":"dsp_cusp_ft_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}, rt::Quantity{T}) where T<:Real\n\nGet energy grid values for given CUSP grid rise times while varying the flat-top time.\n\nReturns\n\n- `e_grid`: Array energy values for the given CUSP rise time grid at a given flat-top time grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_cusp_rt_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}}} where T<:Real","page":"API","title":"LegendDSP.dsp_cusp_rt_optimization","text":"dsp_cusp_rt_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T},; ft::Quantity{T}=4.0u\"µs\") where T<:Real\n\nGet ENC noise grid values for given CUSP grid rise times.\n\nReturns\n\n- `enc_cusp_grid`: Array ENC noise values for the given CUSP rise time grid\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_decay_times-Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig}","page":"API","title":"LegendDSP.dsp_decay_times","text":"dsp_decay_times(wvfs::AbstractSamples, start::Real, stop::Real)\n\nGet statistics on the logarhithmic of the tail of the wvfs in the interval (start,stop).\n\nReturns\n\nτ: decay time in µs\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_icpc-Union{Tuple{T}, Tuple{Q}, Tuple{Q, DSPConfig, Unitful.Quantity{T}, PropDicts.PropDict}} where {Q<:TypedTables.Table, T<:Real}","page":"API","title":"LegendDSP.dsp_icpc","text":"dsp_icpc(data::Q, config::DSPConfig, τ::Quantity{T}, pars_filter::PropDict) where {Q <: Table, T<:Real}\n\nDSP for ICPC detectors. It needs the decay time τ of the detector and the filter parameters pars_filter for the optimal filter parameters for the Trap, CUSP and ZAC filter. \n\nInput data\n\nThe input data is a table with the following columns:\n\nwaveform: waveform data\nbaseline: baseline from FADC\ntimestamp: timestamp from FADC\neventnumber: event ID from FADC\ndaqenergy: energy from FADC\n\nOutput data\n\nThe output data is a table with the following columns:\n\nblmean: baseline mean\nblsigma: baseline sigma\nblslope: baseline slope\nbloffset: baseline offset\ntailmean: tail mean after PZ correction\ntailsigma: tail sigma after PZ correction\ntailslope: tail slope after PZ correction\ntailoffset: tail offset after PZ correction\nt0: start time of waveform drift\nt50: timepoint of 50% of waveform maximum\nt80: timepoint of 80% of waveform maximum\nt0_current: timepoint of current rise start\ntail_τ: tail decay time\ntail_mean: tail mean before PZ correction\ntail_sigma: tail sigma before PZ correction\ne_max: maximum of waveform\ne_min: minimum of waveform\ne_10410: energy of waveform with trapezoidal filter of 10µs rise time with 4µs flat-top\ne_313: energy of waveform with trapezoidal filter of 3µs rise time with 1µs flat-top\ne_10410_inv: maximum of inverted waveform with trapezoidal filter of 10µs rise time with 4µs flat-top\ne_313_inv: maximum of inverted waveform with trapezoidal filter of 3µs rise time with 1µs flat-top\nt0_inv: start time of inverted waveform drift\ne_trap: energy of waveform with trapezoidal filter of optimized rise and flat-top time\ne_cusp: energy of waveform with CUSP filter of optimized rise and flat-top time\ne_zac: energy of waveform with ZAC filter of optimized rise and flat-top time\nqdrift: Q-drift parameter\nlq: LQ parameter\na: current maximum with optimal Savitzky-Golay filter length parameter\nblfc: baseline from FADC\ntimestamp: timestamp from FADC\neventID_fadc: event ID from FADC\ne_fc: energy from FADC\npretrace_diff: difference between first sample and baseline mean\nrt1090: rise time between 10% and 90% of waveform maximum\nrt1099: rise time between 10% and 99% of waveform maximum\nrt9099: rise time between 90% and 99% of waveform maximum\ndrift_time: drift time between t0 and 90% of waveform maximum\ninTrace_intersect: position of in-trace pile-up\ninTrace_n: multiplicity of in-trace pile-up\nn_sat_low: number of samples the waveform is saturated at low of FADC range\nn_sat_high: number of samples the waveform is saturated at high of FADC range\nn_sat_low_cons: number of consecutive samples the waveform is saturated at low of FADC range\nn_sat_high_cons: number of consecutive samples the waveform is saturated at high of FADC range\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_puls-Union{Tuple{Q}, Tuple{Q, DSPConfig}} where Q<:TypedTables.Table","page":"API","title":"LegendDSP.dsp_puls","text":"dsp_puls(data::Q, config::DSPConfig) where {Q <: Table}\n\nDSP function for pulser processing.\n\nInput data\n\nThe input data is a table with the following columns:\n\nwaveform: waveform data\nbaseline: baseline data\ntimestamp: timestamp data\neventnumber: event number data\ndaqenergy: energy data\n\nOutput data\n\nThe output data is a table with the following columns:\n\nblmean: baseline mean\nblsigma: baseline sigma\nblslope: baseline slope\nbloffset: baseline offset\nt50: timepoint of 50% of waveform maximum\ne_max: maximum of waveform\ne_10410: energy of waveform with trapezoidal filter of 10µs rise time with 4µs flat-top\nblfc: baseline from FADC\ntimestamp: timestamp\neventID_fadc: event number from FADC\ne_fc: energy from FADC\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_sg_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, PropDicts.PropDict}} where T<:Real","page":"API","title":"LegendDSP.dsp_sg_optimization","text":"dsp_sg_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}, pars_filter::PropDict) where T<:Real\n\nOptimize the Savitzky-Golay filter parameters for a given waveform set.\n\nReturns\n\n- `aoe`: Array of efficiency values for the given Savitzky-Golay filter parameters\n- `e`: Array of energy values for the given Savitzky-Golay filter parameters\n- `blmean`: Baseline mean value\n- `blslope`: Baseline slope value\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_sipm-Union{Tuple{Q}, Tuple{Q, PropDicts.PropDict, PropDicts.PropDict}} where Q<:TypedTables.Table","page":"API","title":"LegendDSP.dsp_sipm","text":"dsp_sipm(data::Q, config::PropDict, pars_threshold::PropDict)\n\nDSP routine for SiPM data. It needs the threshold parameters from the threshold scan for the given SiPM channel as well as the discharge threshold parameters.\n\nInput data\n\nThe input data is a table with the following columns:\n\nwaveform: waveform data\nbaseline: baseline data\ntimestamp: timestamp data\neventnumber: event number data\ndaqenergy: energy data\n\nOutput data\n\nThe output data is a table with the following columns:\n\nblfc: baseline from FADC\ntimestamp: timestamp\neventID_fadc: event number from FADC\ne_fc: energy from FADC\ntrig_pos: trigger positions from DSP\ntrig_max: trigger maxima from DSP\ntrig_pos_DC: trigger positions of discharges\ntrig_max_DC: trigger maxima of discharges\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_trap_ft_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, Unitful.Quantity{T}}} where T<:Real","page":"API","title":"LegendDSP.dsp_trap_ft_optimization","text":"dsp_trap_ft_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}, rt::Quantity{T}) where T<:Real\n\nGet energy grid values for given trap grid rise times while varying the flat-top time.\n\nReturns\n\n- `e_grid`: Array energy values for the given trap rise time grid at a given flat-top time grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_trap_rt_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}}} where T<:Real","page":"API","title":"LegendDSP.dsp_trap_rt_optimization","text":"dsp_trap_rt_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T},; ft::Quantity{T}=4.0u\"µs\") where T<:Real\n\nGet ENC noise grid values for given trap grid rise times.\n\nReturns\n\n- `enc_trap_grid`: Array ENC noise values for the given trap rise time grid\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_zac_ft_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, Unitful.Quantity{T}}} where T<:Real","page":"API","title":"LegendDSP.dsp_zac_ft_optimization","text":"dsp_zac_ft_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}, rt::Quantity{T}) where T<:Real\n\nGet energy grid values for given ZAC grid rise times while varying the flat-top time.\n\nReturns:     - e_grid: Array energy values for the given ZAC rise time grid at a given flat-top time grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_zac_rt_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}}} where T<:Real","page":"API","title":"LegendDSP.dsp_zac_rt_optimization","text":"dsp_zac_rt_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T},; ft::Quantity{T}=4.0u\"µs\") where T<:Real\n\nGet ENC noise grid values for given ZAC grid rise times.\n\nReturns\n\n- `enc_zac_grid`: Array ENC noise values for the given ZAC rise time grid\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.extrema3points-Union{Tuple{T}, Tuple{T, T, T}} where T<:(Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real)","page":"API","title":"LegendDSP.extrema3points","text":"extrema3points(y1::T,y2::T,y3::T)::T where {T<:AbstractFloat}\n\nCalculate the extrema of a parabola defined by three points.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.get_t0-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, T}} where T<:Real","page":"API","title":"LegendDSP.get_t0","text":"get_t0(wvfs_pz::ArrayOfRDWaveforms, t0_threshold::T) where T<:Real\n\nGet t0 for each waveform in wvfs_pz by using a fast asymetric trapezoidal filter and a fixed threshold at t0_threshold. The filter is truncated to the range 0µs to 60µs where the Ge trigger is expected in FlashCam.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.get_t50-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, Array{T}}} where T<:Real","page":"API","title":"LegendDSP.get_t50","text":"get_t50(wvfs_pz::ArrayOfRDWaveforms, wvf_max::T) where T<:Real\n\nGet t50 for each waveform in wvfs_pz by intersecting the waveform with a fixed threshold at wvf_max * 0.5.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.get_t80-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, Array{T}}} where T<:Real","page":"API","title":"LegendDSP.get_t80","text":"get_t80(wvfs_pz::ArrayOfRDWaveforms, wvf_max::T) where T<:Real\n\nGet t80 for each waveform in wvfs_pz by intersecting the waveform with a fixed threshold at wvf_max * 0.8.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.get_wvf_maximum","page":"API","title":"LegendDSP.get_wvf_maximum","text":"get_wvf_maximum(signal::AbstractSamples, start::Real, stop::Real)\nget_wvf_maximum(signal::RDWaveform, start::RealQuantity, stop::RealQuantity)\n\nGet the maximum of a signal in the interval (start,stop) by quadaratic interpolation.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDSP.saturation","page":"API","title":"LegendDSP.saturation","text":"tailstats(signal::AbstractSamples, start::Real, stop::Real)\ntailstats(signal::RDWaveform, start::RealQuantity, stop::RealQuantity)\n\nGet statistics on the logarhithmic of the tail of a signal in the interval (start,stop).\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDSP.tailstats","page":"API","title":"LegendDSP.tailstats","text":"tailstats(signal::AbstractSamples, start::Real, stop::Real)\ntailstats(signal::RDWaveform, start::RealQuantity, stop::RealQuantity)\n\nGet statistics on the logarhithmic of the tail of a signal in the interval (start,stop) by fitting a linear function.\n\n\n\n\n\n","category":"function"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#LegendDSP.jl","page":"Home","title":"LegendDSP.jl","text":"","category":"section"}]
}
