var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:module]","category":"page"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type, :constant]","category":"page"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [LegendDSP]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"api/#LegendDSP.LegendDSP","page":"API","title":"LegendDSP.LegendDSP","text":"LegendDSP\n\nTemplate for Julia packages.\n\n\n\n\n\n","category":"module"},{"location":"api/#LegendDSP.DSPConfig","page":"API","title":"LegendDSP.DSPConfig","text":"DSPConfig{T <: Real}\n\nConfiguration parameters for DSP algorithms.\n\nFields\n\nenc_pickoff::Quantity{<:T}: pick-off time for ENC noise calculations\nbl_window::ClosedInterval{Quantity{<:T}}: fit window for basline extraction\ntail_window::ClosedInterval{Quantity{<:T}}: fit window for decay time extraction\ninTraceCut_std_threshold::T: in-trace pile-up rejector threshold in standard deviations\nt0_threshold::T: ADC threshold for t0 determination\ne_grid_rt_trap::StepRangeLen{Quantity{<:T}}: rise time grid scan range for trapezoidal filter\ne_grid_ft_trap::StepRangeLen{Quantity{<:T}}: flat-top time grid scan range for trapezoidal filter\ne_grid_rt_zac::StepRangeLen{Quantity{<:T}}: rise time grid scan range for ZAC filter\ne_grid_ft_zac::StepRangeLen{Quantity{<:T}}: flat-top time grid scan range for ZAC filter\ne_grid_rt_cusp::StepRangeLen{Quantity{<:T}}: rise time grid scan range for CUSP filter\ne_grid_ft_cusp::StepRangeLen{Quantity{<:T}}: flat-top time grid scan range for CUSP filter\na_grid_rt_sg::StepRangeLen{Quantity{<:T}}: window length grid scan range for SG filter\n\nExamples\n\nusing LegendDSP\nusing LegendDataManagement\n\nl200 = LegendData(:l200)\nfilekey = start_filekey(l200, (:p03, :r000, :cal))\ndsp_config = DSPConfig(dataprod_config(l200).dsp(filekey).default)\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDSP.IntersectMaximum","page":"API","title":"LegendDSP.IntersectMaximum","text":"struct IntersectMaximum <: Function\n\nFinds the intersects of a Y with a threshold and picking the maximum in a given time window. Constructors:\n\nIntersectMaximum(; fields...)\n\nFields:\n\nmintot::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: minimum time-over-threshold\nmaxtot::Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real: maximum time-over-threshold for max to appear\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDSP._create_dsp_config-Tuple{PropDicts.PropDict}","page":"API","title":"LegendDSP._create_dsp_config","text":"_create_dsp_config(dsp_metadata::PropDicts.PropDict)\n\nCreate a DSPConfig from a PropDict of DSP metadata.\n\nArguments\n\ndsp_metadata::PropDicts.PropDict: DSP metadata\n\nReturns\n\ndsp_config::DSPConfig: DSP configuration\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_cusp_ft_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, Unitful.Quantity{T}}} where T<:Real","page":"API","title":"LegendDSP.dsp_cusp_ft_optimization","text":"dsp_cusp_ft_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}, rt::Quantity{T}) where T<:Real\n\nGet energy grid values for given CUSP grid rise times while varying the flat-top time.\n\nReturns\n\n- `e_grid`: Array energy values for the given CUSP rise time grid at a given flat-top time grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_cusp_rt_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}}} where T<:Real","page":"API","title":"LegendDSP.dsp_cusp_rt_optimization","text":"dsp_cusp_rt_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T},; ft::Quantity{T}=4.0u\"µs\") where T<:Real\n\nGet ENC noise grid values for given CUSP grid rise times.\n\nReturns\n\n- `enc_cusp_grid`: Array ENC noise values for the given CUSP rise time grid\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_decay_times-Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig}","page":"API","title":"LegendDSP.dsp_decay_times","text":"dsp_decay_times(wvfs::AbstractSamples, config::DSPConfig)\n\nGet statistics on the logarhithmic of the tail of the wvfs in the interval tail_window.\n\nReturns\n\nτ: decay time in µs\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_icpc-Union{Tuple{T}, Tuple{Q}, Tuple{Q, DSPConfig, Unitful.Quantity{T}, PropDicts.PropDict}} where {Q<:TypedTables.Table, T<:Real}","page":"API","title":"LegendDSP.dsp_icpc","text":"dsp_icpc(data::Q, config::DSPConfig, τ::Quantity{T}, pars_filter::PropDict) where {Q <: Table, T<:Real}\n\nDSP for ICPC detectors. It needs the decay time τ of the detector and the filter parameters pars_filter for the optimal filter parameters for the Trap, CUSP and ZAC filter. \n\nInput data\n\nThe input data is a table with the following columns:\n\nwaveform: waveform data\nbaseline: baseline from FADC\ntimestamp: timestamp from FADC\neventnumber: event ID from FADC\ndaqenergy: energy from FADC\n\nOutput data\n\nThe output data is a table with the following columns:\n\nblmean: baseline mean\nblsigma: baseline sigma\nblslope: baseline slope\nbloffset: baseline offset\ntailmean: tail mean after PZ correction\ntailsigma: tail sigma after PZ correction\ntailslope: tail slope after PZ correction\ntailoffset: tail offset after PZ correction\nt0: start time of waveform drift\nt10: timepoint of 10% of waveform maximum\nt50: timepoint of 50% of waveform maximum\nt80: timepoint of 80% of waveform maximum\nt90: timepoint of 90% of waveform maximum\nt99: timepoint of 99% of waveform maximum\nt50_current: timepoint of current rise to 50% of maximum\ntail_τ: tail decay time\ntail_mean: tail mean before PZ correction\ntail_sigma: tail sigma before PZ correction\ne_max: maximum of waveform\ne_min: minimum of waveform\ne_10410: energy of waveform with trapezoidal filter of 10µs rise time with 4µs flat-top\ne_313: energy of waveform with trapezoidal filter of 3µs rise time with 1µs flat-top\ne_10410_inv: maximum of inverted waveform with trapezoidal filter of 10µs rise time with 4µs flat-top\ne_313_inv: maximum of inverted waveform with trapezoidal filter of 3µs rise time with 1µs flat-top\nt0_inv: start time of inverted waveform drift\ne_trap: energy of waveform with trapezoidal filter of optimized rise and flat-top time\ne_cusp: energy of waveform with CUSP filter of optimized rise and flat-top time\ne_zac: energy of waveform with ZAC filter of optimized rise and flat-top time\nqdrift: Q-drift parameter\nlq: LQ parameter\na: current maximum with optimal Savitzky-Golay filter length parameter\nblfc: baseline from FADC\ntimestamp: timestamp from FADC\neventID_fadc: event ID from FADC\ne_fc: energy from FADC\npretrace_diff: difference between first sample and baseline mean\ndrift_time: drift time between t0 and 90% of waveform maximum\ninTrace_intersect: position of in-trace pile-up\ninTrace_n: multiplicity of in-trace pile-up\nn_sat_low: number of samples the waveform is saturated at low of FADC range\nn_sat_high: number of samples the waveform is saturated at high of FADC range\nn_sat_low_cons: number of consecutive samples the waveform is saturated at low of FADC range\nn_sat_high_cons: number of consecutive samples the waveform is saturated at high of FADC range\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_puls-Union{Tuple{Q}, Tuple{Q, DSPConfig}} where Q<:TypedTables.Table","page":"API","title":"LegendDSP.dsp_puls","text":"dsp_puls(data::Q, config::DSPConfig) where {Q <: Table}\n\nDSP function for pulser processing.\n\nInput data\n\nThe input data is a table with the following columns:\n\nwaveform: waveform data\nbaseline: baseline data\ntimestamp: timestamp data\neventnumber: event number data\ndaqenergy: energy data\n\nOutput data\n\nThe output data is a table with the following columns:\n\nblmean: baseline mean\nblsigma: baseline sigma\nblslope: baseline slope\nbloffset: baseline offset\nt50: timepoint of 50% of waveform maximum\ne_max: maximum of waveform\ne_10410: energy of waveform with trapezoidal filter of 10µs rise time with 4µs flat-top\nblfc: baseline from FADC\ntimestamp: timestamp\neventID_fadc: event number from FADC\ne_fc: energy from FADC\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_sg_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, PropDicts.PropDict}} where T<:Real","page":"API","title":"LegendDSP.dsp_sg_optimization","text":"dsp_sg_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}, pars_filter::PropDict) where T<:Real\n\nOptimize the Savitzky-Golay filter parameters for a given waveform set.\n\nReturns\n\n- `aoe`: Array of efficiency values for the given Savitzky-Golay filter parameters\n- `e`: Array of energy values for the given Savitzky-Golay filter parameters\n- `blmean`: Baseline mean value\n- `blslope`: Baseline slope value\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_sipm-Union{Tuple{Q}, Tuple{Q, PropDicts.PropDict, PropDicts.PropDict}} where Q<:TypedTables.Table","page":"API","title":"LegendDSP.dsp_sipm","text":"dsp_sipm(data::Q, config::PropDict, pars_threshold::PropDict)\n\nDSP routine for SiPM data. It needs the threshold parameters from the threshold scan for the given SiPM channel as well as the discharge threshold parameters.\n\nInput data\n\nThe input data is a table with the following columns:\n\nwaveform: waveform data\nbaseline: baseline data\ntimestamp: timestamp data\neventnumber: event number data\ndaqenergy: energy data\n\nOutput data\n\nThe output data is a table with the following columns:\n\nblfc: baseline from FADC\ntimestamp: timestamp\neventID_fadc: event number from FADC\ne_fc: energy from FADC\ntrig_pos: trigger positions from DSP\ntrig_max: trigger maxima from DSP\ntrig_pos_DC: trigger positions of discharges\ntrig_max_DC: trigger maxima of discharges\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_trap_ft_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, Unitful.Quantity{T}}} where T<:Real","page":"API","title":"LegendDSP.dsp_trap_ft_optimization","text":"dsp_trap_ft_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}, rt::Quantity{T}) where T<:Real\n\nGet energy grid values for given trap grid rise times while varying the flat-top time.\n\nReturns\n\n- `e_grid`: Array energy values for the given trap rise time grid at a given flat-top time grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_trap_rt_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}}} where T<:Real","page":"API","title":"LegendDSP.dsp_trap_rt_optimization","text":"dsp_trap_rt_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T},; ft::Quantity{T}=4.0u\"µs\") where T<:Real\n\nGet ENC noise grid values for given trap grid rise times.\n\nReturns\n\n- `enc_trap_grid`: Array ENC noise values for the given trap rise time grid\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_zac_ft_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, Unitful.Quantity{T}}} where T<:Real","page":"API","title":"LegendDSP.dsp_zac_ft_optimization","text":"dsp_zac_ft_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}, rt::Quantity{T}) where T<:Real\n\nGet energy grid values for given ZAC grid rise times while varying the flat-top time.\n\nReturns:     - e_grid: Array energy values for the given ZAC rise time grid at a given flat-top time grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_zac_rt_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}}} where T<:Real","page":"API","title":"LegendDSP.dsp_zac_rt_optimization","text":"dsp_zac_rt_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T},; ft::Quantity{T}=4.0u\"µs\") where T<:Real\n\nGet ENC noise grid values for given ZAC grid rise times.\n\nReturns\n\n- `enc_zac_grid`: Array ENC noise values for the given ZAC rise time grid\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.extrema3points-Union{Tuple{T}, Tuple{T, T, T}} where T<:(Union{Unitful.Quantity{<:var\"#s10\"}, var\"#s10\"} where var\"#s10\"<:Real)","page":"API","title":"LegendDSP.extrema3points","text":"extrema3points(y1::T,y2::T,y3::T)::T where {T<:AbstractFloat}\n\nCalculate the extrema of a parabola defined by three points.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.get_intracePileUp-Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, Real, IntervalSets.ClosedInterval{Union{Unitful.Quantity{var\"#s76\", 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s76\", 𝐓, U}} where {L, S}} where {var\"#s76\"<:Real, U}}}","page":"API","title":"LegendDSP.get_intracePileUp","text":"get_intracePileUp(wvfs::ArrayOfRDWaveforms, sigma_threshold::Real, blmin::Unitful.Time{<:Real}, blmax::Unitful.Time{<:Real}; mintot::Unitful.Time=100.0u\"ns\")\n\nGet position and multiplicity of in-trace pile-up as intersect of reversed derivative signal with threshold as multiple of std. The wvfs have to be a current signal.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.get_qdrift-Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, Array{<:Union{Unitful.Quantity{var\"#s63\", 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s63\", 𝐓, U}} where {L, S}} where {var\"#s63\"<:Real, U}}, StepRangeLen{<:Union{Unitful.Quantity{var\"#s61\", 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s61\", 𝐓, U}} where {L, S}} where {var\"#s61\"<:Real, U}}}","page":"API","title":"LegendDSP.get_qdrift","text":"get_qdrift(wvfs::ArrayOfRDWaveforms, t_start::Array{Unitful.Time{T}}, Δt::UnitRange{Unitful.Time{T}}; pol_power::Int=3, sign_est_length::Unitful.Time=100u\"ns\")\n\nGet the Q-drift parameter for each waveform in wvfs by integrating the waveform with gain = 1 and using a polynomial signal estimator of order pol_power and length sign_est_length to estimate the signal.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.get_t0-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, T}} where T<:Real","page":"API","title":"LegendDSP.get_t0","text":"get_t0(wvfs_pz::ArrayOfRDWaveforms, t0_threshold::T) where T<:Real\n\nGet t0 for each waveform in wvfs_pz by using a fast asymetric trapezoidal filter and a fixed threshold at t0_threshold. The filter is truncated to the range 0µs to 60µs where the Ge trigger is expected in FlashCam.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.get_threshold-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), U<:(Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real), N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, Union{Array{T}, T}}} where T<:Real","page":"API","title":"LegendDSP.get_threshold","text":"get_threshold(wvfs::ArrayOfRDWaveforms, threshold::Array{T}) where T<:Real\n\nGet threshold for each waveform in wvfs by intersecting the waveform with a threshold per waveform or globally.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.get_wvf_maximum","page":"API","title":"LegendDSP.get_wvf_maximum","text":"get_wvf_maximum(signal::AbstractSamples, start::Real, stop::Real)\nget_wvf_maximum(signal::RDWaveform, start::RealQuantity, stop::RealQuantity)\n\nGet the maximum of a signal in the interval (start,stop) by quadaratic interpolation.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDSP.saturation","page":"API","title":"LegendDSP.saturation","text":"tailstats(signal::AbstractSamples, start::Real, stop::Real)\ntailstats(signal::RDWaveform, start::RealQuantity, stop::RealQuantity)\n\nGet statistics on the logarhithmic of the tail of a signal in the interval (start,stop).\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDSP.tailstats","page":"API","title":"LegendDSP.tailstats","text":"tailstats(signal::AbstractSamples, start::Real, stop::Real)\ntailstats(signal::RDWaveform, start::RealQuantity, stop::RealQuantity)\n\nGet statistics on the logarhithmic of the tail of a signal in the interval (start,stop) by fitting a linear function.\n\n\n\n\n\n","category":"function"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#LegendDSP.jl","page":"Home","title":"LegendDSP.jl","text":"","category":"section"}]
}
