var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:module]","category":"page"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type, :constant]","category":"page"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/#LegendDSP.LegendDSP","page":"API","title":"LegendDSP.LegendDSP","text":"LegendDSP\n\nTemplate for Julia packages.\n\n\n\n\n\n","category":"module"},{"location":"api/#LegendDSP.DSPConfig","page":"API","title":"LegendDSP.DSPConfig","text":"DSPConfig{T <: Real}\n\nConfiguration parameters for DSP algorithms.\n\nFields\n\nenc_pickoff::Quantity{<:T}: pick-off time for ENC noise calculations\nbl_window::ClosedInterval{Quantity{<:T}}: fit window for basline extraction\ntail_window::ClosedInterval{Quantity{<:T}}: fit window for decay time extraction\ninTraceCut_std_threshold::T: in-trace pile-up rejector threshold in standard deviations\nt0_threshold::T: ADC threshold for t0 determination\ne_grid_rt_trap::StepRangeLen{Quantity{<:T}}: rise time grid scan range for trapezoidal filter\ne_grid_ft_trap::StepRangeLen{Quantity{<:T}}: flat-top time grid scan range for trapezoidal filter\ne_grid_rt_zac::StepRangeLen{Quantity{<:T}}: rise time grid scan range for ZAC filter\ne_grid_ft_zac::StepRangeLen{Quantity{<:T}}: flat-top time grid scan range for ZAC filter\ne_grid_rt_cusp::StepRangeLen{Quantity{<:T}}: rise time grid scan range for CUSP filter\ne_grid_ft_cusp::StepRangeLen{Quantity{<:T}}: flat-top time grid scan range for CUSP filter\na_grid_rt_sg::StepRangeLen{Quantity{<:T}}: window length grid scan range for SG filter\n\nExamples\n\nusing LegendDSP\nusing LegendDataManagement\n\nl200 = LegendData(:l200)\nfilekey = start_filekey(l200, (:p03, :r000, :cal))\ndsp_config = DSPConfig(dataprod_config(l200).dsp(filekey).default)\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDSP.DerivativeFilter","page":"API","title":"LegendDSP.DerivativeFilter","text":"struct DerivativeFilter <: AbstractRadIIRFilter\n\nWorking example:\n\nusing LegendDSP\nusing Unitful\n\nsignal = rand(100)\nt = range(0u\"ms\", 20u\"ms\", 100)\n\nwf = RDWaveform(t, signal)\nflt = DerivativeFilter()\nwf_new = flt(wf)\n\nConstructors:\n\nDerivativeFilter(; fields...)\n\nFields:\n\ngain::Union{Real, Unitful.AbstractQuantity{<:Real}}: Filter gain\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDSP.IntersectMaximum","page":"API","title":"LegendDSP.IntersectMaximum","text":"struct IntersectMaximum <: Function\n\nFinds the intersects of a Y with a threshold and picking the maximum in a given time window. Constructors:\n\nIntersectMaximum(; fields...)\n\nFields:\n\nmintot::Union{Real, Unitful.AbstractQuantity{<:Real}}: minimum time-over-threshold\nmaxtot::Union{Real, Unitful.AbstractQuantity{<:Real}}: maximum time-over-threshold for max to appear\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDSP.ModifiedSincFilter","page":"API","title":"LegendDSP.ModifiedSincFilter","text":"struct ModifiedSincFilter{T<:RealQuantity} <: AbstractRadFIRFilter{}\n\nA Modified-Sinc filter Working example\n\nusing RadiationDetectorSignals\nusing Unitful\n\nn = 600\nnoise = 1.\nt = range(0u\"μs\", 20u\"μs\", 2*n)\nsignal = vcat(zeros(n), 10*ones(n)) + (noise*rand(2*n) .- noise/2)\nwf = RDWaveform(t, signal)\n\n# define filter parameters and filter\nflt = ModifiedSincFilter(d=4, m=1u\"μs\")\n\n# apply filter to signal\nwf_new = flt(wf)\n\nConstructors:\n\nModifiedSincFilter(; fields...)\n\nFields:\n\nd::Int64: degree of the filter determining the number of extrema in the kernel\nm::Union{Real, Unitful.AbstractQuantity{<:Real}}: half-width of the kernel\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDSP.MovingWindowFilter","page":"API","title":"LegendDSP.MovingWindowFilter","text":"struct MovingWindowFilter <: AbstractRadFIRFilter\n\napply left moving average window to signal. The exact computations are:\n        yₙ = yₙ₋₁ + (xₙ - x₁)/l,    for n ∈ {1, …, l}\n        yₙ = yₙ₋₁ + (xₙ - xₙ₋ₗ)/l,    for n ∈ {l+1, …, L}\n\n\nConstructors:\n\nMovingWindowFilter(; fields...)\n\nFields:\n\nlength::Union{Real, Unitful.AbstractQuantity{<:Real}}: length of the moving average window\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDSP.MovingWindowMultiFilter","page":"API","title":"LegendDSP.MovingWindowMultiFilter","text":"struct MovingWindowMultiFilter <: AbstractRadFIRFilter\n\napply left and right moving average windows to signal. Working example:\n\nusing RadiationDetectorSignals\nusing Unitful\n\nsignal = rand(100)\nt = range(0u\"ms\", 20u\"ms\", 100)\n\nwf = RDWaveform(t, signal)\nflt = MovingWindowMultiFilter(1u\"ms\")\nwf_new = flt(wf)\n\nConstructors:\n\nMovingWindowMultiFilter(; fields...)\n\nFields:\n\nlength::Union{Real, Unitful.AbstractQuantity{<:Real}}: size of the moving average window\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDSP.MultiIntersect","page":"API","title":"LegendDSP.MultiIntersect","text":"struct MultiIntersect <: Function     Finds the x values at which a signal exceeds the provided      threshold_ratios the first time.      Constructors:     * MultiIntersect(; fields...)     Fields:\n\nthreshold_ratios::Vector{Float64}: ratios which determine the thresholds\nmintot::Union{Real, Unitful.AbstractQuantity{<:Real}}: minimum time-over-threshold\nn::Int64: half window length of polynomial fit\nd::Int64: degree of polynomial\nsampling_rate::Int64: upsampling rate\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDSP.TimeAxisFilter","page":"API","title":"LegendDSP.TimeAxisFilter","text":"struct TimeAxisFilter <: AbstractRadIIRFilter\n\nUpdates the time range step to period and shifts the time axis by offset.\n\nWorking example:\n\nusing LegendDSP\nusing RadiationDetectorSignals\nusing Unitful\n\nsignal = rand(100)\nt = range(0u\"ms\", 20u\"ms\", 100)\n\nwf = RDWaveform(t, signal)\nflt = TimeAxisFilter(4u\"ns\")\nwf_new = flt(wf)\n\nConstructors:\n\nTimeAxisFilter(; fields...)\n\nFields:\n\nperiod::Union{Real, Unitful.AbstractQuantity{<:Real}}: Filter period\noffset::Union{Real, Unitful.AbstractQuantity{<:Real}}: Filter offset\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDSP.WeightedSavitzkyGolayFilter","page":"API","title":"LegendDSP.WeightedSavitzkyGolayFilter","text":"struct WeightedSavitzkyGolayFilter{T<:RealQuantity} <: AbstractRadFIRFilter\n\nA Weighted-Savitzky-Golay filter. Working example:\n\nusing RadiationDetectorSignals\nusing Unitful\n\nn = 600\nnoise = 1.\nt = range(0u\"μs\", 20u\"μs\", 2*n)\nsignal = vcat(zeros(n), 10*ones(n)) + (noise*rand(2*n) .- noise/2)\nwf = RDWaveform(t, signal)\n\n# define filter parameters and filter\nflt = WeightedSavitzkyGolayFilter(length=1u\"μs\", degree=3, weightType=2)\n\n# apply filter to signal\nwf_new = flt(wf)\n\nConstructors:\n\nWeightedSavitzkyGolayFilter(; fields...)\n\nFields:\n\nlength::Union{Real, Unitful.AbstractQuantity{<:Real}}: total filter length\ndegree::Int64: Polynomial degree\nweightType::Int64: weight function to use\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDSP.WhittakerHendersonFilter","page":"API","title":"LegendDSP.WhittakerHendersonFilter","text":"struct WhittakerHendersonFilter <: AbstractRadSigFilter{LinearFiltering}\n\nA Whittaker-Henderson filter. Working example: ```julia using RadiationDetectorSignals using Unitful\n\nn = 600 noise = 1. t = range(0u\"μs\", 20u\"μs\", 2n) signal = vcat(zeros(n), 10ones(n)) + (noiserand(2n) .- noise/2) wf = RDWaveform(t, signal)\n\ndefine filter parameters and filter\n\nflt = WhittakerHendersonFilter(p=3, λ=4)\n\napply filter to signal\n\nwf_new = flt(wf)\n\n\n\n\n\n","category":"type"},{"location":"api/#LegendDSP._create_dsp_config-Tuple{PropDicts.PropDict}","page":"API","title":"LegendDSP._create_dsp_config","text":"_create_dsp_config(dsp_metadata::PropDicts.PropDict)\n\nCreate a DSPConfig from a PropDict of DSP metadata.\n\nArguments\n\ndsp_metadata::PropDicts.PropDict: DSP metadata\n\nReturns\n\ndsp_config::DSPConfig: DSP configuration\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.banded_cholesky_solve!-Tuple{AbstractVector, AbstractMatrix, AbstractVector}","page":"API","title":"LegendDSP.banded_cholesky_solve!","text":"banded_cholesky_solve!(x::AbstractVector, A::AbstractMatrix, y::AbstractVector)\n\nsolve the linear equation AA'x = y and store the result in x, where A is the cholesky decomposition of a banded centro symmetric matrix. A[1, i] is the diagonal, A[2, i] is the first subdiagonal and so on.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.choleskyL!-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"API","title":"LegendDSP.choleskyL!","text":"choleskyL!(b::AbstractMatrix{T})\n\ninplace cholesky decomposition of a banded symmetric matrix, where  b[1, i] contains the diagonal elements, b[2, i] the elements of the  first subdiagonal and so on.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_cusp_ft_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:Union{Real, Unitful.AbstractQuantity{<:Real}}, U<:Union{Real, Unitful.AbstractQuantity{<:Real}}, N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, Unitful.Quantity{T}}} where T<:Real","page":"API","title":"LegendDSP.dsp_cusp_ft_optimization","text":"dsp_cusp_ft_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}, rt::Quantity{T}) where T<:Real\n\nGet energy grid values for given CUSP grid rise times while varying the flat-top time.\n\nReturns\n\n- `e_grid`: Array energy values for the given CUSP rise time grid at a given flat-top time grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_cusp_rt_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:Union{Real, Unitful.AbstractQuantity{<:Real}}, U<:Union{Real, Unitful.AbstractQuantity{<:Real}}, N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}}} where T<:Real","page":"API","title":"LegendDSP.dsp_cusp_rt_optimization","text":"dsp_cusp_rt_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T},; ft::Quantity{T}=4.0u\"µs\") where T<:Real\n\nGet ENC noise grid values for given CUSP grid rise times.\n\nReturns\n\n- `enc_cusp_grid`: Array ENC noise values for the given CUSP rise time grid\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_decay_times-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:Union{Real, Unitful.AbstractQuantity{<:Real}}, U<:Union{Real, Unitful.AbstractQuantity{<:Real}}, N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, IntervalSets.ClosedInterval{<:Union{Unitful.Quantity{var\"#s92\", 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s92\", 𝐓, U}} where {L, S}} where {var\"#s92\"<:T, U}}, IntervalSets.ClosedInterval{<:Union{Unitful.Quantity{var\"#s90\", 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s90\", 𝐓, U}} where {L, S}} where {var\"#s90\"<:T, U}}}} where T<:Real","page":"API","title":"LegendDSP.dsp_decay_times","text":"dsp_decay_times(wvfs::ArrayOfRDWaveforms, bl_window::ClosedInterval{<:Unitful.Time{<:T}}, tail_window::ClosedInterval{<:Unitful.Time{<:T}})\ndsp_decay_times(wvfs::ArrayOfRDWaveforms, config::DSPConfig)\n\nGet statistics on the logarhithmic of the tail of the wvfs in the interval tail_window.\n\nReturns\n\nτ: decay time in µs\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_icpc-Union{Tuple{T}, Tuple{Q}, Tuple{Q, DSPConfig, Unitful.Quantity{T}, PropDicts.PropDict}} where {Q<:TypedTables.Table, T<:Real}","page":"API","title":"LegendDSP.dsp_icpc","text":"dsp_icpc(data::Q, config::DSPConfig, τ::Quantity{T}, pars_filter::PropDict) where {Q <: Table, T<:Real}\n\nDSP for ICPC detectors. It needs the decay time τ of the detector and the filter parameters pars_filter for the optimal filter parameters for the Trap, CUSP and ZAC filter. \n\nInput data\n\nThe input data is a table with the following columns:\n\nwaveform: waveform data\nbaseline: baseline from FADC\ntimestamp: timestamp from FADC\neventnumber: event ID from FADC\ndaqenergy: energy from FADC\n\nOutput data\n\nThe output data is a table with the following columns:\n\nblmean: baseline mean\nblsigma: baseline sigma\nblslope: baseline slope\nbloffset: baseline offset\ntailmean: tail mean after PZ correction\ntailsigma: tail sigma after PZ correction\ntailslope: tail slope after PZ correction\ntailoffset: tail offset after PZ correction\nt0: start time of waveform drift\nt10: timepoint of 10% of waveform maximum\nt50: timepoint of 50% of waveform maximum\nt80: timepoint of 80% of waveform maximum\nt90: timepoint of 90% of waveform maximum\nt99: timepoint of 99% of waveform maximum\nt50_current: timepoint of current rise to 50% of maximum\ntail_τ: tail decay time\ntail_mean: tail mean before PZ correction\ntail_sigma: tail sigma before PZ correction\ne_max: maximum of waveform\ne_min: minimum of waveform\ne_10410: energy of waveform with trapezoidal filter of 10µs rise time with 4µs flat-top\ne_313: energy of waveform with trapezoidal filter of 3µs rise time with 1µs flat-top\ne_10410_inv: maximum of inverted waveform with trapezoidal filter of 10µs rise time with 4µs flat-top\ne_313_inv: maximum of inverted waveform with trapezoidal filter of 3µs rise time with 1µs flat-top\nt0_inv: start time of inverted waveform drift\ne_trap: energy of waveform with trapezoidal filter of optimized rise and flat-top time\ne_cusp: energy of waveform with CUSP filter of optimized rise and flat-top time\ne_zac: energy of waveform with ZAC filter of optimized rise and flat-top time\nqdrift: Q-drift parameter\nlq: LQ parameter\na: current maximum with optimal Savitzky-Golay filter length parameter\nblfc: baseline from FADC\ntimestamp: timestamp from FADC\neventID_fadc: event ID from FADC\ne_fc: energy from FADC\npretrace_diff: difference between first sample and baseline mean\ndrift_time: drift time between t0 and 90% of waveform maximum\ninTrace_intersect: position of in-trace pile-up\ninTrace_n: multiplicity of in-trace pile-up\nn_sat_low: number of samples the waveform is saturated at low of FADC range\nn_sat_high: number of samples the waveform is saturated at high of FADC range\nn_sat_low_cons: number of consecutive samples the waveform is saturated at low of FADC range\nn_sat_high_cons: number of consecutive samples the waveform is saturated at high of FADC range\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_icpc_compressed-Union{Tuple{T}, Tuple{Q}, Tuple{Q, DSPConfig, Unitful.Quantity{T}, PropDicts.PropDict}} where {Q<:TypedTables.Table, T<:Real}","page":"API","title":"LegendDSP.dsp_icpc_compressed","text":"dsp_icpc_compressed(data::Q, config::DSPConfig, τ::Quantity{T}, pars_filter::PropDict) where {Q <: Table, T<:Real}\n\nDSP for ICPC detectors. It needs the decay time τ of the detector and the filter parameters pars_filter for the optimal filter parameters for the Trap, CUSP and ZAC filter. \n\nInput data\n\nThe input data is a table with the following columns:\n\nwaveform: waveform data\nbaseline: baseline from FADC\ntimestamp: timestamp from FADC\neventnumber: event ID from FADC\ndaqenergy: energy from FADC\n\nOutput data\n\nThe output data is a table with the following columns:\n\nblmean: baseline mean\nblsigma: baseline sigma\nblslope: baseline slope\nbloffset: baseline offset\ntailmean: tail mean after PZ correction\ntailsigma: tail sigma after PZ correction\ntailslope: tail slope after PZ correction\ntailoffset: tail offset after PZ correction\nt0: start time of waveform drift\nt10: timepoint of 10% of waveform maximum\nt50: timepoint of 50% of waveform maximum\nt80: timepoint of 80% of waveform maximum\nt90: timepoint of 90% of waveform maximum\nt99: timepoint of 99% of waveform maximum\nt50_current: timepoint of current rise to 50% of maximum\ntail_τ: tail decay time\ntail_mean: tail mean before PZ correction\ntail_sigma: tail sigma before PZ correction\ne_max: maximum of waveform\ne_min: minimum of waveform\ne_10410: energy of waveform with trapezoidal filter of 10µs rise time with 4µs flat-top\ne_313: energy of waveform with trapezoidal filter of 3µs rise time with 1µs flat-top\ne_10410_inv: maximum of inverted waveform with trapezoidal filter of 10µs rise time with 4µs flat-top\ne_313_inv: maximum of inverted waveform with trapezoidal filter of 3µs rise time with 1µs flat-top\nt0_inv: start time of inverted waveform drift\ne_trap: energy of waveform with trapezoidal filter of optimized rise and flat-top time\ne_cusp: energy of waveform with CUSP filter of optimized rise and flat-top time\ne_zac: energy of waveform with ZAC filter of optimized rise and flat-top time\nqdrift: Q-drift parameter\nlq: LQ parameter\na: current maximum with optimal Savitzky-Golay filter length parameter\nblfc: baseline from FADC\ntimestamp: timestamp from FADC\neventID_fadc: event ID from FADC\ne_fc: energy from FADC\npretrace_diff: difference between first sample and baseline mean\ndrift_time: drift time between t0 and 90% of waveform maximum\ninTrace_intersect: position of in-trace pile-up\ninTrace_n: multiplicity of in-trace pile-up\nn_sat_low: number of samples the waveform is saturated at low of FADC range\nn_sat_high: number of samples the waveform is saturated at high of FADC range\nn_sat_low_cons: number of consecutive samples the waveform is saturated at low of FADC range\nn_sat_high_cons: number of consecutive samples the waveform is saturated at high of FADC range\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_puls-Union{Tuple{Q}, Tuple{Q, DSPConfig}} where Q<:TypedTables.Table","page":"API","title":"LegendDSP.dsp_puls","text":"dsp_puls(data::Q, config::DSPConfig) where {Q <: Table}\n\nDSP function for pulser processing.\n\nInput data\n\nThe input data is a table with the following columns:\n\nwaveform: waveform data\nbaseline: baseline data\ntimestamp: timestamp data\neventnumber: event number data\ndaqenergy: energy data\n\nOutput data\n\nThe output data is a table with the following columns:\n\nblmean: baseline mean\nblsigma: baseline sigma\nblslope: baseline slope\nbloffset: baseline offset\nt50: timepoint of 50% of waveform maximum\ne_max: maximum of waveform\ne_10410: energy of waveform with trapezoidal filter of 10µs rise time with 4µs flat-top\nblfc: baseline from FADC\ntimestamp: timestamp\neventID_fadc: event number from FADC\ne_fc: energy from FADC\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_puls_compressed-Union{Tuple{Q}, Tuple{Q, DSPConfig}} where Q<:TypedTables.Table","page":"API","title":"LegendDSP.dsp_puls_compressed","text":"dsp_puls_compressed(data::Q, config::DSPConfig) where {Q <: Table}\n\nDSP function for pulser processing.\n\nInput data\n\nThe input data is a table with the following columns:\n\nwaveform: waveform data\nbaseline: baseline data\ntimestamp: timestamp data\neventnumber: event number data\ndaqenergy: energy data\n\nOutput data\n\nThe output data is a table with the following columns:\n\nblmean: baseline mean\nblsigma: baseline sigma\nblslope: baseline slope\nbloffset: baseline offset\nt50: timepoint of 50% of waveform maximum\ne_max: maximum of waveform\ne_10410: energy of waveform with trapezoidal filter of 10µs rise time with 4µs flat-top\nblfc: baseline from FADC\ntimestamp: timestamp\neventID_fadc: event number from FADC\ne_fc: energy from FADC\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_qc_flt_optimization-Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:Union{Real, Unitful.AbstractQuantity{<:Real}}, U<:Union{Real, Unitful.AbstractQuantity{<:Real}}, N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Union{Unitful.Quantity{var\"#s96\", 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s96\", 𝐓, U}} where {L, S}} where {var\"#s96\"<:Real, U}, Function}","page":"API","title":"LegendDSP.dsp_qc_flt_optimization","text":"dsp_flt_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Unitful.Time{<:Real}, f_evaluate_qc::Function)\n\nGet QC DSP for filter parameter optimization for a given waveform set.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_qc_flt_optimization_compressed-Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:Union{Real, Unitful.AbstractQuantity{<:Real}}, U<:Union{Real, Unitful.AbstractQuantity{<:Real}}, N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Union{Unitful.Quantity{var\"#s96\", 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s96\", 𝐓, U}} where {L, S}} where {var\"#s96\"<:Real, U}, Function}","page":"API","title":"LegendDSP.dsp_qc_flt_optimization_compressed","text":"dsp_qc_flt_optimization_compressed(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Unitful.Time{<:Real}, f_evaluate_qc::Function)\n\nGet QC DSP for filter parameter optimization for a given waveform set.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_qdrift_flt_optimization-Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:Union{Real, Unitful.AbstractQuantity{<:Real}}, U<:Union{Real, Unitful.AbstractQuantity{<:Real}}, N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, Vector{<:Real}, DSPConfig, Union{Unitful.Quantity{var\"#s94\", 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s94\", 𝐓, U}} where {L, S}} where {var\"#s94\"<:Real, U}}","page":"API","title":"LegendDSP.dsp_qdrift_flt_optimization","text":"dsp_qdrift_flt_optimization(wvfs::ArrayOfRDWaveforms, blmean::Vector{<:Real}, config::DSPConfig, τ::Unitful.Time{<:Real})\n\nGet QDrift filter parameter optimization for a given waveform set.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_sg_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:Union{Real, Unitful.AbstractQuantity{<:Real}}, U<:Union{Real, Unitful.AbstractQuantity{<:Real}}, N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, PropDicts.PropDict}} where T<:Real","page":"API","title":"LegendDSP.dsp_sg_optimization","text":"dsp_sg_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}, pars_filter::PropDict) where T<:Real\n\nOptimize the Savitzky-Golay filter parameters for a given waveform set.\n\nReturns\n\n- `aoe`: Array of efficiency values for the given Savitzky-Golay filter parameters\n- `e`: Array of energy values for the given Savitzky-Golay filter parameters\n- `blmean`: Baseline mean value\n- `blslope`: Baseline slope value\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_sg_optimization_compressed-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:Union{Real, Unitful.AbstractQuantity{<:Real}}, U<:Union{Real, Unitful.AbstractQuantity{<:Real}}, N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:Union{Real, Unitful.AbstractQuantity{<:Real}}, U<:Union{Real, Unitful.AbstractQuantity{<:Real}}, N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, PropDicts.PropDict}} where T<:Real","page":"API","title":"LegendDSP.dsp_sg_optimization_compressed","text":"dsp_sg_optimization_compressed(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}, pars_filter::PropDict) where T<:Real\n\nOptimize the Savitzky-Golay filter parameters for a given waveform set.\n\nReturns\n\n- `aoe`: Array of efficiency values for the given Savitzky-Golay filter parameters\n- `e`: Array of energy values for the given Savitzky-Golay filter parameters\n- `blmean`: Baseline mean value\n- `blslope`: Baseline slope value\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_sg_sipm_optimization_compressed","page":"API","title":"LegendDSP.dsp_sg_sipm_optimization_compressed","text":"dsp_sg_sipm_optimization_compressed(wvfs::ArrayOfRDWaveforms, dsp_config::PropDict, optimization_config::PropDict)\n\nThis function calculates DSP grid to find the optimal thresholds for the SiPMs.\n\nArguments\n\nwvfs::ArrayOfRDWaveforms: Array of RDWaveforms\ndsp_config::PropDict: Configuration parameters for the DSP\noptimization_config::PropDict: Configuration parameters for the optimization\n\nReturns\n\nTable: Table with the optimal thresholds for the SiPMs\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDSP.dsp_sg_sipm_thresholds_compressed-Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:Union{Real, Unitful.AbstractQuantity{<:Real}}, U<:Union{Real, Unitful.AbstractQuantity{<:Real}}, N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, Union{Unitful.Quantity{var\"#s96\", 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s96\", 𝐓, U}} where {L, S}} where {var\"#s96\"<:Real, U}, PropDicts.PropDict}","page":"API","title":"LegendDSP.dsp_sg_sipm_thresholds_compressed","text":"dsp_sg_sipm_thresholds_compressed(wvfs::ArrayOfRDWaveforms, config::PropDict)\n\nThis function calculates the baseline of the waveforms and the baseline of the waveforms with the sign flipped. The function is used to calculate the thresholds for the SiPMs.\n\nArguments\n\nwvfs::ArrayOfRDWaveforms: Array of RDWaveforms\nconfig::PropDict: Configuration parameters\n\nReturns\n\nTable: Table with the baseline of the waveforms and the baseline of the waveforms with the sign flipped\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_sipm-Union{Tuple{Q}, Tuple{Q, PropDicts.PropDict, PropDicts.PropDict}} where Q<:TypedTables.Table","page":"API","title":"LegendDSP.dsp_sipm","text":"dsp_sipm(data::Q, config::PropDict, pars_threshold::PropDict)\n\nDSP routine for SiPM data. It needs the threshold parameters from the threshold scan for the given SiPM channel as well as the discharge threshold parameters.\n\nInput data\n\nThe input data is a table with the following columns:\n\nwaveform: waveform data\nbaseline: baseline data\ntimestamp: timestamp data\neventnumber: event number data\ndaqenergy: energy data\n\nOutput data\n\nThe output data is a table with the following columns:\n\nblfc: baseline from FADC\ntimestamp: timestamp\neventID_fadc: event number from FADC\ne_fc: energy from FADC\ntrig_pos: trigger positions from DSP\ntrig_max: trigger maxima from DSP\ntrig_pos_DC: trigger positions of discharges\ntrig_max_DC: trigger maxima of discharges\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_sipm_compressed-Union{Tuple{Q}, Tuple{Q, PropDicts.PropDict, PropDicts.PropDict}} where Q<:TypedTables.Table","page":"API","title":"LegendDSP.dsp_sipm_compressed","text":"dsp_sipm_compressed(data::Q, config::PropDict, pars_threshold::PropDict)\n\nDSP routine for SiPM data. It needs the threshold parameters from the threshold scan for the given SiPM channel as well as the discharge threshold parameters.\n\nInput data\n\nThe input data is a table with the following columns:\n\nwaveform: waveform data\nbaseline: baseline data\ntimestamp: timestamp data\neventnumber: event number data\ndaqenergy: energy data\n\nOutput data\n\nThe output data is a table with the following columns:\n\nblfc: baseline from FADC\ntimestamp: timestamp\neventID_fadc: event number from FADC\ne_fc: energy from FADC\ntrig_pos: trigger positions from DSP\ntrig_max: trigger maxima from DSP\ntrig_pos_DC: trigger positions of discharges\ntrig_max_DC: trigger maxima of discharges\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_trap_ft_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:Union{Real, Unitful.AbstractQuantity{<:Real}}, U<:Union{Real, Unitful.AbstractQuantity{<:Real}}, N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, Unitful.Quantity{T}}} where T<:Real","page":"API","title":"LegendDSP.dsp_trap_ft_optimization","text":"dsp_trap_ft_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}, rt::Quantity{T}) where T<:Real\n\nGet energy grid values for given trap grid rise times while varying the flat-top time.\n\nReturns\n\n- `e_grid`: Array energy values for the given trap rise time grid at a given flat-top time grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_trap_rt_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:Union{Real, Unitful.AbstractQuantity{<:Real}}, U<:Union{Real, Unitful.AbstractQuantity{<:Real}}, N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}}} where T<:Real","page":"API","title":"LegendDSP.dsp_trap_rt_optimization","text":"dsp_trap_rt_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T},; ft::Quantity{T}=4.0u\"µs\") where T<:Real\n\nGet ENC noise grid values for given trap grid rise times.\n\nReturns\n\n- `enc_trap_grid`: Array ENC noise values for the given trap rise time grid\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_zac_ft_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:Union{Real, Unitful.AbstractQuantity{<:Real}}, U<:Union{Real, Unitful.AbstractQuantity{<:Real}}, N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}, Unitful.Quantity{T}}} where T<:Real","page":"API","title":"LegendDSP.dsp_zac_ft_optimization","text":"dsp_zac_ft_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T}, rt::Quantity{T}) where T<:Real\n\nGet energy grid values for given ZAC grid rise times while varying the flat-top time.\n\nReturns:     - e_grid: Array energy values for the given ZAC rise time grid at a given flat-top time grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.dsp_zac_rt_optimization-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:Union{Real, Unitful.AbstractQuantity{<:Real}}, U<:Union{Real, Unitful.AbstractQuantity{<:Real}}, N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, DSPConfig, Unitful.Quantity{T}}} where T<:Real","page":"API","title":"LegendDSP.dsp_zac_rt_optimization","text":"dsp_zac_rt_optimization(wvfs::ArrayOfRDWaveforms, config::DSPConfig, τ::Quantity{T},; ft::Quantity{T}=4.0u\"µs\") where T<:Real\n\nGet ENC noise grid values for given ZAC grid rise times.\n\nReturns\n\n- `enc_zac_grid`: Array ENC noise values for the given ZAC rise time grid\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.extrema3points-Union{Tuple{T}, Tuple{T, T, T}} where T<:Union{Real, Unitful.AbstractQuantity{<:Real}}","page":"API","title":"LegendDSP.extrema3points","text":"extrema3points(y1::T,y2::T,y3::T)::T where {T<:AbstractFloat}\n\nCalculate the extrema of a parabola defined by three points.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.extremestats","page":"API","title":"LegendDSP.extremestats","text":"extremestats(signal::AbstractSamples, start::Real, stop::Real)\nextremestats(signal::RDWaveform, start::RealQuantity, stop::RealQuantity)\n\nGet the extrema and their time positions on signal in the interval (start,stop). Output is in the format (min = .., max = .., tmin = .., tmax = ..)\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDSP.get_intracePileUp-Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:Union{Real, Unitful.AbstractQuantity{<:Real}}, U<:Union{Real, Unitful.AbstractQuantity{<:Real}}, N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, Real, IntervalSets.ClosedInterval{<:Union{Unitful.Quantity{var\"#s88\", 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s88\", 𝐓, U}} where {L, S}} where {var\"#s88\"<:Real, U}}}","page":"API","title":"LegendDSP.get_intracePileUp","text":"get_intracePileUp(wvfs::ArrayOfRDWaveforms, sigma_threshold::Real, bl_window::ClosedInterval{<:Unitful.Time{<:Real}}; mintot::Unitful.Time=100.0u\"ns\")\n\nGet position and multiplicity of in-trace pile-up as intersect of reversed derivative signal with threshold as multiple of std. The wvfs have to be a current signal.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.get_qc_classifier","page":"API","title":"LegendDSP.get_qc_classifier","text":"get_qc_classifier(wvfs::ArrayOfRDWaveforms, f_evaluate_qc::Function)\n\nGet a classifier for quality cuts using the given waveforms and evaluation function which evulates a predefined SVM model.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDSP.get_qc_classifier_compressed","page":"API","title":"LegendDSP.get_qc_classifier_compressed","text":"get_qc_classifier_compressed(wvfs::ArrayOfRDWaveforms, f_evaluate_qc::Function)\nget_qc_classifier_compressed(wvfs::ArrayOfRDWaveforms, f_evaluate_qc::Function, config::DSPConfig)\n\nGet a classifier for quality cuts using the given waveforms and evaluation function which evulates a predefined SVM model.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDSP.get_qc_ml_func-Tuple{Matrix{<:Real}, Vector{<:Real}, PropDicts.PropDict}","page":"API","title":"LegendDSP.get_qc_ml_func","text":"get_qc_ml_func(dwts_norm::Matrix{<:Real}, dc_labels::Vector{<:Real}, hyperparams::PropDict)\n\nCreate a function that takes a signal and returns the prediction using the given hyperparameters and discrete wavelet transforms.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.get_qdrift-Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:Union{Real, Unitful.AbstractQuantity{<:Real}}, U<:Union{Real, Unitful.AbstractQuantity{<:Real}}, N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, Array{<:Union{Unitful.Quantity{var\"#s82\", 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s82\", 𝐓, U}} where {L, S}} where {var\"#s82\"<:Real, U}}, StepRangeLen{<:Union{Unitful.Quantity{var\"#s80\", 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{var\"#s80\", 𝐓, U}} where {L, S}} where {var\"#s80\"<:Real, U}}}","page":"API","title":"LegendDSP.get_qdrift","text":"get_qdrift(wvfs::ArrayOfRDWaveforms, t_start::Array{Unitful.Time{T}}, Δt::UnitRange{Unitful.Time{T}}; pol_power::Int=3, sign_est_length::Unitful.Time=100u\"ns\")\n\nGet the Q-drift parameter for each waveform in wvfs by integrating the waveform with gain = 1 and using a polynomial signal estimator of order pol_power and length sign_est_length to estimate the signal.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.get_t0-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:Union{Real, Unitful.AbstractQuantity{<:Real}}, U<:Union{Real, Unitful.AbstractQuantity{<:Real}}, N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, T}} where T<:Real","page":"API","title":"LegendDSP.get_t0","text":"get_t0(wvfs_pz::ArrayOfRDWaveforms, t0_threshold::T) where T<:Real\n\nGet t0 for each waveform in wvfs_pz by using a fast asymetric trapezoidal filter and a fixed threshold at t0_threshold. The filter is truncated to the range 0µs to 60µs where the Ge trigger is expected in FlashCam.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.get_threshold-Union{Tuple{T}, Tuple{StructArrays.StructArray{<:RadiationDetectorSignals.RDWaveform{T, U, TV, UV} where {TV<:AbstractVector{T}, UV<:AbstractVector{U}}, N, @NamedTuple{time::VVT, signal::VVU}} where {T<:Union{Real, Unitful.AbstractQuantity{<:Real}}, U<:Union{Real, Unitful.AbstractQuantity{<:Real}}, N, VVT<:(AbstractVector{<:AbstractVector{T}}), VVU<:(AbstractVector{<:AbstractVector{U}})}, Union{Array{T}, T}}} where T<:Real","page":"API","title":"LegendDSP.get_threshold","text":"get_threshold(wvfs::ArrayOfRDWaveforms, threshold::Array{T}) where T<:Real\n\nGet threshold for each waveform in wvfs by intersecting the waveform with a threshold per waveform or globally.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.get_wvf_maximum","page":"API","title":"LegendDSP.get_wvf_maximum","text":"get_wvf_maximum(signal::AbstractSamples, start::Real, stop::Real)\nget_wvf_maximum(signal::RDWaveform, start::RealQuantity, stop::RealQuantity)\n\nGet the maximum of a signal in the interval (start,stop) by quadaratic interpolation.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDSP.makeFitWeights-Union{Tuple{U}, Tuple{U, Int64}} where U<:Integer","page":"API","title":"LegendDSP.makeFitWeights","text":"makeFitWeights(d::Int, m::Int) where {U}\n\nreturn the weights for the linear fit user for linear extrapolation at  at the right boundary.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.makeIPlusLambdaDprimeD-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T","page":"API","title":"LegendDSP.makeIPlusLambdaDprimeD","text":"makeIPlusLambdaDprimeD(λ::T, p::Int, N::Int) where {T}\n\nbuild the centro symmetric banded matrix which needs to be inverted  later: I + λ*D'D D is the finite difference matrix of order p.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendDSP.saturation","page":"API","title":"LegendDSP.saturation","text":"tailstats(signal::AbstractSamples, start::Real, stop::Real)\ntailstats(signal::RDWaveform, start::RealQuantity, stop::RealQuantity)\n\nGet statistics on the logarhithmic of the tail of a signal in the interval (start,stop).\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDSP.tailstats","page":"API","title":"LegendDSP.tailstats","text":"tailstats(signal::AbstractSamples, start::Real, stop::Real)\ntailstats(signal::RDWaveform, start::RealQuantity, stop::RealQuantity)\n\nGet statistics on the logarhithmic of the tail of a signal in the interval (start,stop) by fitting a linear function.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDSP.thresholdstats","page":"API","title":"LegendDSP.thresholdstats","text":"thresholdstats(signal::AbstractSamples, min::Real, min::Real)\nthresholdstats(signal::RDWaveform, min::RealQuantity, max::RealQuantity)\n\nGet the standard deviation of all samples in a signal that are within  the lower bound min and the upper bound max. If no values for min or max are passed, the respective bound is ignored.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendDSP.weighted_linear_reg-Tuple{AbstractVector, AbstractVector}","page":"API","title":"LegendDSP.weighted_linear_reg","text":"weighted_linear_reg(w::AbstractVector, y::AbstractVector)\n\nDo a weighted linear regression of the data y with weights w and return the offset and slope. its assumed that x is a range from 1 to length(y)\n\n\n\n\n\n","category":"method"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#LegendDSP.jl","page":"Home","title":"LegendDSP.jl","text":"","category":"section"}]
}
